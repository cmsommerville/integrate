from sqlalchemy import Column
from alembic.operations.ops import (
    CreateTableOp,
    DropTableOp,
    ExecuteSQLOp,
)


def get_temporal_table_name(table_name):
    return f"{table_name}_history"


def is_temporal_table(op):
    has_row_eff_dts = any(
        [
            True
            for col in op.columns
            if col.name == "row_eff_dts" and isinstance(col, Column)
        ]
    )
    has_row_exp_dts = any(
        [
            True
            for col in op.columns
            if col.name == "row_exp_dts" and isinstance(col, Column)
        ]
    )
    return has_row_eff_dts and has_row_exp_dts


def add_security_policy(op: CreateTableOp):
    table_name = op.table_name
    schema = op.schema
    if schema is None:
        schema = "dbo"
    if op.info.get("rls") is None:
        return None

    rls_rule = op.info.get("rls")
    if rls_rule == "user_role":
        return ExecuteSQLOp(
            sqltext=f"""CREATE SECURITY POLICY rls.policy_rls__{table_name}
                ADD FILTER PREDICATE rls.fn_rls__user_role(auth_role_code) ON {schema}.{table_name}
                WITH (STATE = ON)"""
        )
    if rls_rule == "user_name":
        return ExecuteSQLOp(
            sqltext=f"""CREATE SECURITY POLICY rls.policy_rls__{table_name}
                ADD FILTER PREDICATE rls.fn_rls__user_name(user_name) ON {schema}.{table_name}
                WITH (STATE = ON)"""
        )
    raise ValueError(f"Unknown RLS rule: {rls_rule}")


def drop_security_policy(op: DropTableOp):
    if op.info.get("rls") is None:
        return None
    table_name = op.table_name
    return ExecuteSQLOp(
        sqltext=f"""DROP SECURITY POLICY rls.policy_rls__{table_name}"""
    )


def create_temporal_table(op: CreateTableOp):
    table_name = op.table_name
    temporal_table_name = get_temporal_table_name(table_name)
    schema = op.schema

    if not is_temporal_table(op):
        return []

    if schema is None:
        schema = "dbo"
    alter_table1 = ExecuteSQLOp(
        sqltext=f"ALTER TABLE {schema}.{table_name} ADD PERIOD FOR SYSTEM_TIME (row_eff_dts, row_exp_dts)"
    )
    alter_table2 = ExecuteSQLOp(
        sqltext=f"ALTER TABLE {schema}.{table_name} SET (SYSTEM_VERSIONING = ON (HISTORY_TABLE={schema}.{temporal_table_name}))"
    )
    return [alter_table1, alter_table2]


def drop_temporal_table(op: DropTableOp):
    table_name = op.table_name
    temporal_table_name = get_temporal_table_name(table_name)
    schema = op.schema
    if not is_temporal_table(op._reverse):
        return []

    if schema is None:
        schema = "dbo"
    alter_table1 = ExecuteSQLOp(
        sqltext=f"ALTER TABLE {schema}.{table_name} SET ( SYSTEM_VERSIONING = OFF )"
    )
    alter_table2 = ExecuteSQLOp(sqltext=f"DROP TABLE {schema}.{temporal_table_name}")
    return [alter_table1, alter_table2]


def process_upgrade_ops(script):
    ops = [*script.upgrade_ops.ops]
    new_upgrade_ops = []
    for op in ops:
        if getattr(op, "info", {}).get("skip_autogenerated", False):
            continue

        # order here is important
        new_upgrade_ops.append(op)
        if isinstance(op, CreateTableOp):
            newops = create_temporal_table(op)
            new_upgrade_ops.extend(newops)

            rls = add_security_policy(op)
            if rls is not None:
                new_upgrade_ops.append(rls)

    script.upgrade_ops.ops = new_upgrade_ops
    return script


def process_downgrade_ops(script):
    ops = [*script.downgrade_ops.ops]
    new_downgrade_ops = []
    for op in ops:
        if getattr(op, "info", {}).get("skip_autogenerated", False):
            continue
        if isinstance(op, DropTableOp):
            newops = drop_temporal_table(op)
            new_downgrade_ops.extend(newops)
            rls = drop_security_policy(op)
            if rls is not None:
                new_downgrade_ops.append(rls)

        # this original drop operation needs to be after the temporal alters
        new_downgrade_ops.append(op)
    script.downgrade_ops.ops = new_downgrade_ops
    return script
